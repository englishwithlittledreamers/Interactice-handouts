<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Passage: Why fairy tales are really scary tales</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff; /* Ensures white background */
        }
        /* Highlight styles - Copied from the provided HTML */
        .highlight-yellow { background-color: #FEF9C3; } /* Yellow-100 */
        .highlight-blue { background-color: #DBEAFE; } /* Blue-100 */
        .highlight-green { background-color: #D1FAE5; } /* Green-100 */
        .highlight-pink { background-color: #FCE7F3; } /* Pink-100 */
        .highlighted-text {
            /* Ensures highlighted text is treated as a single unit for selection */
            display: inline;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 bg-white">
    <div class="bg-white p-6 sm:p-8 md:p-10 rounded-xl w-full max-w-4xl border border-gray-200 shadow-lg">
        <div id="readingPassageContent" class="space-y-4 text-gray-700 text-base sm:text-lg leading-relaxed select-text">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-4">Why fairy tales are really scary tales</h1>
            <p>Some people think that fairy tales are just stories to amuse children, but their universal and enduring appeal may be due to more serious reasons</p>

            <p>People of every culture tell each other fairy tales but the same story often takes a variety of forms in different parts of the world. In the story of <em>Little Red Riding Hood</em> that European children are familiar with, a young girl on the way to see her grandmother meets a wolf and tells him where she is going. The wolf runs on ahead and disposes of the grandmother, then gets into bed dressed in the grandmother’s clothes to wait for Little Red Riding Hood. You may think you know the story – but which version? In some versions, the wolf swallows up the grandmother, while in others it locks her in a cupboard. In some stories Red Riding Hood gets the better of the wolf on her own, while in others a hunter or a woodcutter hears her cries and comes to her rescue.</p>

            <p>The universal appeal of these tales is frequently attributed to the idea that they contain cautionary messages: in the case of <em>Little Red Riding Hood</em>, to listen to your mother, and avoid talking to strangers. ‘It might be what we find interesting about this story is that it’s got this survival-relevant information in it,’ says anthropologist Jamie Tehrani at Durham University in the UK. But his research suggests otherwise. ‘We have this huge gap in our knowledge about the history and prehistory of storytelling, despite the fact that we know this genre is an incredibly ancient one,’ he says. That hasn’t stopped anthropologists, folklorists* and other academics devising theories to explain the importance of fairy tales in human society. Now Tehrani has found a way to test these ideas, borrowing a technique from evolutionary biologists.</p>

            <p>To work out the evolutionary history, development and relationships among groups of organisms, biologists compare the characteristics of living species in a process called ‘phylogenetic analysis’. Tehrani has used the same approach to compare related versions of fairy tales to discover how they have evolved and which elements have survived longest.</p>

            <p>Tehrani’s analysis focused on <em>Little Red Riding Hood</em> in its many forms, which include another Western fairy tale known as <em>The Wolf and the Kids</em>. Checking for variants of these two tales and similar stories from Africa, East Asia and other regions, he ended up with 58 stories recorded from oral traditions. Once his phylogenetic analysis had established that they were indeed related, he used the same methods to explore how they have developed and altered over time.</p>

            <p>First he tested some assumptions about which aspects of the story alter least as it evolves, indicating their importance. Folklorists believe that what happens in a story is more central to the story than the characters in it – that visiting a relative, only to be met by a scary animal in disguise, is more fundamental than whether the visitor is a little girl or three siblings, or the animal is a tiger instead of a wolf.</p>

            <p>However, Tehrani found no significant difference in the rate of evolution of incidents compared with that of characters. ‘Certain episodes are very stable because they are crucial to the story, but there are lots of other details that can evolve quite freely,’ he says. Neither did his analysis support the theory that the central section of a story is the most conserved part. He found no significant difference in the flexibility of events there compared with the beginning or the end.</p>

            <p>But the really big surprise came when he looked at the cautionary elements of the story. ‘Studies on hunter-gatherer folk tales suggest that these narratives include really important information about the environment and the possible dangers that may be faced there – stuff that’s relevant to survival,’ he says. Yet in his analysis such elements were just as flexible as seemingly trivial details. What, then, is important enough to be reproduced from generation to generation?</p>

            <p>The answer, it would appear, is fear – blood-thirsty and gruesome aspects of the story, such as the eating of the grandmother by the wolf, turned out to be the best preserved of all. Why are these details retained by generations of storytellers, when other features are not? Tehrani has an idea: ‘In an oral context, a story won’t survive because of one great teller. It also needs to be interesting when it’s told by someone who’s not necessarily a great storyteller.’ Maybe being swallowed whole by a wolf, then cut out of its stomach alive is so gripping that it helps the story remain popular, no matter how badly it’s told.</p>

            <p>Jack Zipes at the University of Minnesota, Minneapolis, is unconvinced by Tehrani’s views on fairy tales. ‘Even if they’re gruesome, they won’t stick unless they matter,’ he says. He believes the perennial theme of women as victims in stories like <em>Little Red Riding Hood</em> explains why they continue to feel relevant. But Tehrani points out that although this is often the case in Western versions, it is not always true elsewhere. In Chinese and Japanese versions, often known as <em>The Tiger Grandmother</em>, the villain is a woman, and in both Iran and Nigeria, the victim is a boy.</p>

            <p>Mathias Clasen at Aarhus University in Denmark isn’t surprised by Tehrani’s findings. ‘Habits and morals change, but the things that scare us, and the fact that we seek out entertainment that’s designed to scare us – those are constant,’ he says. Clasen believes that scary stories teach us what it feels like to be afraid without having to experience real danger, and so build up resistance to negative emotions.
            —<br>
            *Folklorists: those who study traditional stories</p>
        </div>
    </div>

    <!-- Floating Highlight Toolbar -->
    <div id="floatingToolbar" class="absolute hidden bg-gray-800 p-2 rounded-lg shadow-xl flex items-center space-x-2 z-50">
        <button id="toolbarClearBtn" title="Clear Highlight" class="p-1 rounded-full bg-gray-600 hover:bg-gray-700 text-white text-lg leading-none flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
            </svg>
        </button>
        <div id="toolbarYellow" title="Highlight Yellow" class="w-6 h-6 rounded-full cursor-pointer bg-yellow-400 hover:bg-yellow-500 transition-colors duration-200" data-color="highlight-yellow"></div>
        <div id="toolbarBlue" title="Highlight Blue" class="w-6 h-6 rounded-full cursor-pointer bg-blue-400 hover:bg-blue-500 transition-colors duration-200" data-color="highlight-blue"></div>
        <div id="toolbarGreen" title="Highlight Green" class="w-6 h-6 rounded-full cursor-pointer bg-green-400 hover:bg-green-500 transition-colors duration-200" data-color="highlight-green"></div>
        <div id="toolbarPink" title="Highlight Pink" class="w-6 h-6 rounded-full cursor-pointer bg-pink-400 hover:bg-pink-500 transition-colors duration-200" data-color="highlight-pink"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const readingPassageContent = document.getElementById('readingPassageContent');
            const floatingToolbar = document.getElementById('floatingToolbar');
            const toolbarClearBtn = document.getElementById('toolbarClearBtn');
            const toolbarYellow = document.getElementById('toolbarYellow');
            const toolbarBlue = document.getElementById('toolbarBlue');
            const toolbarGreen = document.getElementById('toolbarGreen');
            const toolbarPink = document.getElementById('toolbarPink');

            let lastSelectionRange = null;

            // Function to apply highlight to selected text
            function applyHighlight(colorClass) {
                const selection = window.getSelection();
                let range;

                // Use current selection if available, otherwise use the last stored selection
                if (selection.rangeCount > 0 && !selection.isCollapsed) {
                    range = selection.getRangeAt(0);
                } else if (lastSelectionRange) {
                    range = lastSelectionRange;
                    selection.removeAllRanges(); // Clear current selection before re-adding
                    selection.addRange(range);
                } else {
                    // No text selected or previously selected
                    console.log("No text selected to highlight.");
                    return;
                }

                const selectedText = range.toString().trim();
                if (!selectedText) return; // Do nothing if selection is empty

                const span = document.createElement('span');
                span.classList.add(colorClass);
                span.classList.add('highlighted-text'); // Add a class to identify highlighted spans

                try {
                    // Extract the selected content and put it into the new span
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span); // Insert the new span back into the document

                    selection.removeAllRanges(); // Clear the selection after highlighting
                    floatingToolbar.classList.add('hidden'); // Hide the toolbar
                    lastSelectionRange = null; // Clear last stored range
                } catch (e) {
                    console.error("Error applying highlight:", e);
                    // Provide user feedback if highlighting fails for complex selections
                    // (e.g., selection spanning across multiple non-text nodes)
                }
            }

            // Function to clear highlight from selected text
            function clearSelectedHighlight() {
                const selection = window.getSelection();
                let range;

                // Use current selection if available, otherwise use the last stored selection
                if (selection.rangeCount > 0 && !selection.isCollapsed) {
                    range = selection.getRangeAt(0);
                } else if (lastSelectionRange) {
                    range = lastSelectionRange;
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    console.log("No text selected to clear highlight.");
                    return;
                }

                const selectedNode = range.commonAncestorContainer;
                let highlightedSpan = null;

                // Check if the selected node itself is a highlighted span
                if (selectedNode && selectedNode.nodeType === Node.ELEMENT_NODE && selectedNode.classList.contains('highlighted-text')) {
                    highlightedSpan = selectedNode;
                } else {
                    // Traverse up the DOM tree from the selected node to find a parent highlight span
                    let currentNode = selectedNode;
                    while (currentNode && currentNode !== readingPassageContent && currentNode.parentNode) {
                        if (currentNode.nodeType === Node.ELEMENT_NODE && currentNode.classList.contains('highlighted-text')) {
                            highlightedSpan = currentNode;
                            break;
                        }
                        currentNode = currentNode.parentNode;
                    }
                }

                if (highlightedSpan && highlightedSpan.parentNode) {
                    // Replace the highlighted span with its plain text content
                    const textContent = highlightedSpan.textContent;
                    highlightedSpan.parentNode.replaceChild(document.createTextNode(textContent), highlightedSpan);

                    selection.removeAllRanges(); // Clear the selection
                    floatingToolbar.classList.add('hidden'); // Hide the toolbar
                    lastSelectionRange = null; // Clear last stored range
                } else {
                    console.log("No highlight found to clear for this selection.");
                }
            }

            // Event listeners for toolbar buttons
            toolbarYellow.addEventListener('click', () => applyHighlight('highlight-yellow'));
            toolbarBlue.addEventListener('click', () => applyHighlight('highlight-blue'));
            toolbarGreen.addEventListener('click', () => applyHighlight('highlight-green'));
            toolbarPink.addEventListener('click', () => applyHighlight('highlight-pink'));
            toolbarClearBtn.addEventListener('click', clearSelectedHighlight);

            // Show/hide toolbar on text selection (mouseup event)
            readingPassageContent.addEventListener('mouseup', (event) => {
                const selection = window.getSelection();
                // Check if there's a selection and it's not collapsed (i.e., actual text is selected)
                if (selection.rangeCount > 0 && !selection.isCollapsed) {
                    lastSelectionRange = selection.getRangeAt(0); // Store the current selection range
                    const rect = lastSelectionRange.getBoundingClientRect(); // Get the bounding box of the selection
                    const toolbarHeight = floatingToolbar.offsetHeight;
                    const toolbarWidth = floatingToolbar.offsetWidth;

                    // Position the toolbar above the selected text
                    floatingToolbar.style.top = `${rect.top + window.scrollY - toolbarHeight - 10}px`;
                    // Center the toolbar horizontally above the selection
                    let leftPos = rect.left + window.scrollX + (rect.width / 2) - (toolbarWidth / 2);
                    // Ensure the toolbar stays within the viewport boundaries
                    leftPos = Math.max(10, leftPos); // Prevent going too far left
                    leftPos = Math.min(leftPos, window.innerWidth - toolbarWidth - 10); // Prevent going too far right
                    floatingToolbar.style.left = `${leftPos}px`;

                    floatingToolbar.classList.remove('hidden'); // Show the toolbar
                } else {
                    floatingToolbar.classList.add('hidden'); // Hide if no selection
                    lastSelectionRange = null; // Clear last stored range
                }
            });

            // Hide toolbar when clicking outside the toolbar or passage content
            document.addEventListener('mousedown', (event) => {
                // If the click is not inside the toolbar and not inside the reading passage content
                if (!floatingToolbar.contains(event.target) && !readingPassageContent.contains(event.target)) {
                    floatingToolbar.classList.add('hidden'); // Hide the toolbar
                    lastSelectionRange = null; // Clear last stored range
                }
            });
        });
    </script>
</body>
</html>
